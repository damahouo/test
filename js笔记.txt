sources  断点调试
作用域规定变量能被访问的范围，离开这个范围变量不能被访问，分为局部作用域和全局作用域
局部分为 函数作用域和块作用域{}内的为块作用域  var声明的变量可以被外部访问

<script>和.js的最外层就是所谓的全局作用域再此声明的变量其他变量可以访问使用

作用域链
作用域链本质上是最底层的变量查找机制
在函数被执行时，会优先查找当前函数作用域中查找变量
如果当前作用域找不到则会一次逐级查找父级作用域直到全局作用域，子作用域可以访问父作用域，反之不行

栈 由操作系统自动分配
计数清除法相互引用会造成大量内存泄漏

标记清楚算法将 不再使用的对象 定义为 无法到达的对象
就是从根部（js中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的
那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收

闭包=内层函数+外层函数的变量      内部函数用到外层函数的变量时，才是闭包，只有单纯的嵌套不产生闭包
闭包的作用
封闭函数，实现数据私有，外部也可以访问内部函数的变量
闭包允许将函数与其操作的某些数据（环境）关联起来
闭包可能引起的问题？
可能引起内存泄漏，因为外层一直有函数指向内部变量，标记清除法无法清除

变量提升
允许变量在声明之前就可以被访问到，怪事。仅存于var声明的变量
把所有var声明的变量提升到当前作用域最前面
只提升声明，不提升赋值，声明之前访问 undefined

函数提升：会把所有函数声明提升到当前作用域的最前面
函数表达式必须先声明和赋值，后调用 否则报错

箭头函数更适用那些本来就需要匿名函数的地方，没有arguments，只有剩余函数
箭头函数不会创建自己的this,它只会从自己的作用域的上一层沿用this 
DOM事件不推荐使用箭头函数，因为事件回调函数使用箭头函数时，this指向全局的window

数组解构 从const 【max，min，avg】=【100，60，80】将数组的单元值快速批量的赋值给一系列变量的简洁语法
立即执行函数，数组结构必须加分号，（数组开头的代码前面需要加分号）
【a,,b, ,d】=[1,2,3,4]	3会被忽略   ，a,b,c,d可设置默认值，避免接入undifined
对象结构，要求属性名和变量名必须一致
  const { uname: username, age } = { uname: `鸡哥`, age: 19 }  旧变量名：新变量名 冒号表示前面的值赋值给后面

多级对象结构：
      const pig = {
        name: `佩奇`,
        family: {
          mother: `猪妈妈`,
          father: `猪爸爸`,
          sister: `乔治`,
        },
        age: 6,
      }

      const {
        name,
        family: { mother, father, sister },
        age,
      } = pig

点击事件的回调函数中，this指向函数的调用者，就是点击了谁，this指向谁

构造函数约定
1，命名以大写字母开头
1，只能由 new 操作符来操作

new 构造函数执行步骤：
1.创建一个新的空对象{}
2.构造函数的this指向这个空对象
3.执行构造函数的代码，修改this,添加新的属性
4.返回新对象

创建对象 例子：
function Pig(name, age) {
        this.name = name
        this.age = age
      }
      const p = new Pig(`佩奇`, 18)
      const G = new Pig(`乔治`, 3)
      console.log(p)
：
Pig {name: '佩奇', age: 18}
Pig {name: '乔治', age: 3}

构造函数的属性和方法被称为静态成员 包含静态属性和静态方法
实例对象的属性和方法被称为实例成员 包含实例属性和实例方法

js底层会将字符串包装为复杂数据类型，所以可以用方法

Object.values(obj).join(`分隔符`) 拿到对象中所有的值，并拼接成字符串

面向过程  性能好        不灵活，耦合性差，复用性差
面向对象 灵活，复用性好，耦合性好       性能不好

面向对象三大特点：  继承性 封装性，  多态性
构造函数和原型对象里的this指向实例化对象

继承重点：
Man.prototype = new Person()	子类的原型继承new的父类，避免其他子类继承修改父类
Man.prototype.constructor = Man	子类的原型再重新指回构造函数

原型链！
当访问一个对象的属性包括方法时，首先查找这个对象自身有没有该属性方法
如果没有就查找他的原型（u而就是__proto__指向的prototype原型对象）
如果还没有就查找原相对的的原型（Object的原型对象）
依次类推一直查找到Object为止（null）
__proto_对象原型的意义就在于为对象成员查找机制提供一个方向，或者说时一条路线
可以使用instanceof运算符用于检测及早函数的prototype属性是否出现在某个实例对象的原型链上
总结
所有的对象都有__proto__,指向原型对象
所有的原型对象都有constructor,指向该原型对象的构造函数

深拷贝 
1函数递归实现
2lodash/ _.cloneDeep 
3通过JSON.stringfy()实现
深拷贝总结
1，深拷贝要做到新对象修改时不能影响就对象，利用函数递归
2，判断数组，如果遇到数组，利用函数递归方式，拷贝数组
3，判断对象，如果遇到对象，利用函数递归方式，拷贝对象
4，一定要先判断数组，再判断对象

普通函数中谁调用this指向谁
箭头函数的this和外层this的值一样

scroll.js滚动插件  .resetui()页面滚动到最下方	